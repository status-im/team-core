**Stakeholder:**
**Engineer:** @cammellos, @yenda 

## Introduction

`status-react` gets data stored through the `json-rpc-api`. In the namespace `status-im.ethereum.json-rpc` one can find the list of all authorized json-rpc calls done by `status-react`.

`transit` is a format that allows storing Clojure data literals while being serializable into formats with high-performance processors such as JSON. This means that it allows us to store chunks of the application data "as is" and restore it via sets of `add/get` rpc endpoints. 

When the decision was made to move all data storage to `status-go`, we adopted the absolute rule that no migration should cross the status-go/status-react api boundaries. Therefore no migration of persisted data should involve `status-react` since we already have SQL migrations on `status-go`.

Previously we counted on the fact that `status-go` had a `transit` library and would be able to eventually migrate data stored in blobs of that format, considering it was already using it for messages, however during the security audit, it was decided to get completely rid of it. Messages are now serialized using protobuf, and we are looking into storing all the data in normal form or at worst in `JSON` blobs.

## JSON-RPC API

Here is the list of authorized json-rpc calls in the `status-im.ethereum.json-rpc` namespace:

```clojure
(def json-rpc-api
  {
   ;; these are regular "web3" calls
   "eth_call" {}
   "eth_getBalance"
   {:on-result money/bignumber}
   "eth_estimateGas"
   {:on-result #(money/bignumber (int (* % 1.2)))}
   "eth_gasPrice"
   {:on-result money/bignumber}
   "eth_getBlockByHash"
   {:on-result #(-> (update % :number decode/uint)
                    (update :timestamp decode/uint))}
   "eth_getTransactionByHash" {}
   "eth_getTransactionReceipt" {}
   "eth_newBlockFilter" {:subscription? true}
   "eth_newFilter" {:subscription? true}
   "eth_syncing" {}
   "net_version" {}
   "web3_clientVersion" {}
   ;; these are whisper and chat related calls
   "shhext_post" {}
   "shh_generateSymKeyFromPassword" {}
   "shh_getSymKey" {}
   "shh_markTrustedPeer" {}
   "shhext_requestMessages" {}
   "shhext_sendDirectMessage" {}
   "shhext_sendPublicMessage" {}
   "shhext_enableInstallation" {}
   "shhext_disableInstallation" {}
   "shhext_getOurInstallations" {}
   "shhext_setInstallationMetadata" {}
   "shhext_loadFilters" {}
   "shhext_loadFilter" {}
   "shhext_removeFilters" {}
   "shhext_chats" {}
   "shhext_saveMessages" {}
   "shhext_deleteMessagesFrom" {}
   "shhext_deleteMessagesByChatID" {}
   "shhext_deleteMessage" {}
   "shhext_markMessagesSeen" {}
   "shhext_confirmMessagesProcessedByID" {}
   "shhext_updateMessageOutgoingStatus" {}
   "shhext_chatMessages" {}
   "shhext_saveChat" {}
   "shhext_contacts" {}
   "shhext_prepareContent" {}
   "shhext_blockContact" {}
   ;;TODO not used anywhere?
   "shhext_deleteChat" {}
   "shhext_saveContact" {}
   "shhext_verifyENSNames" {}
   "status_chats" {}
   ;; other calls
   "wallet_getTransfers" {}
   "wallet_getTokensBalances" {}
   "browsers_getBrowsers" {}
   "browsers_addBrowser" {}
   "browsers_deleteBrowser" {}
   "mailservers_getMailserverRequestGaps" {}
   "mailservers_addMailserverRequestGaps" {}
   "mailservers_deleteMailserverRequestGaps" {}
   "mailservers_deleteMailserverRequestGapsByChatID" {}
   "permissions_addDappPermissions" {}
   "permissions_getDappPermissions" {}
   "permissions_deleteDappPermissions" {}
   "settings_saveConfig" {}
   "settings_getConfig" {}
   "settings_getConfigs" {}
   "settings_saveNodeConfig" {}
   "accounts_getAccounts" {}
   "accounts_saveAccounts" {}
   "mailservers_ping" {}
   "mailservers_addMailserver" {}
   "mailservers_getMailservers" {}
   "mailservers_deleteMailserver" {}
   "mailservers_addMailserverTopic" {}
   "mailservers_getMailserverTopics" {}
   "mailservers_deleteMailserverTopic" {}
   "mailservers_addChatRequestRange" {}
   "mailservers_getChatRequestRanges" {}
   "mailservers_deleteChatRequestRange" {}})
```

We are not going to consider the web3 calls here as they are standard, and we are going to ignore the whisper/chat related calls as well as they should not be affected by this issue.
We can also narrow down the list to only the `add` and `save` rpc-calls, which gives us the following list:

### "mailservers_addMailserver"

Passed a single map as argument, which has the following schema and is expected to store `Mailserver` in the database:
```json
{
    "id": "1",
    "name": "my mailserver",
    "address": "enode://...",
    "password": "some-pass",
    "fleet": "beta"
}
```

In `status-go/services/mailservers/database.go` the following datastructure is used:
```golang
type Mailserver struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Address  string `json:"address"`
	Password string `json:"password,omitempty"`
	Fleet    string `json:"fleet"`
}
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS mailservers (
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL,
    address VARCHAR NOT NULL,
    password VARCHAR,
    fleet VARCHAR NOT NULL
) WITHOUT ROWID;
```

We don't need to change any of this.

### "mailservers_addMailserverRequestGaps"

Passed a vector of `MailserverRequestGaps` in the following format and is expected to store them in the database:
```json
{
  "id": "1",
  "chatId": "chat-id",
  "from": 1,
  "to": 2
}
```

In `status-go/services/mailservers/database.go` the following datastructure is used:
```golang
type MailserverRequestGap struct {
	ID     string `json:"id"`
	ChatID string `json:"chatId"`
	From   uint64 `json:"from"`
	To     uint64 `json:"to"`
}
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS mailserver_request_gaps (
    gap_from UNSIGNED INTEGER NOT NULL,
    gap_to UNSIGNED INTEGER NOT NULL,
    id TEXT PRIMARY KEY,
    chat_id TEXT NOT NULL
) WITHOUT ROWID;

CREATE INDEX mailserver_request_gaps_chat_id_idx ON mailserver_request_gaps (chat_id);
```

We don't need to change any of this.

### "mailservers_addMailserverTopic"

Passed a single map as argument, which has the following schema and is expected to store a `MailserverTopic` in the database:
```json
{
    "topic": "topic-as-string",
    "chat-ids": ["a", "list", "of", "chatIDs"],
    "last-request": 1
}
```

In `status-go/services/mailservers/database.go` the following datastructure is used:
```golang
type MailserverTopic struct {
	Topic       string   `json:"topic"`
	ChatIDs     []string `json:"chat-ids"`
	LastRequest int      `json:"last-request"` // default is 1
}
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS mailserver_topics (
    topic VARCHAR PRIMARY KEY,
    chat_ids VARCHAR,
    last_request INTEGER DEFAULT 1
) WITHOUT ROWID;
```

`chat-ids` is a vector of string, and is stored as a `VARCHAR` in the db, which seems reasonable for this use case. We don't need to change any of this.

### "mailservers_addChatRequestRange"

Passed a single map as argument, which has the following schema and is expected to store a `ChatRequestRange` in the database.
```json
{
    "chat-id": "chat-id-001",
    "lowest-request-from": 1567693421154,
    "highest-request-to": 1567693576779 
}
```

In `status-go/services/mailservers/database.go` the following datastructure is used:
```golang
type ChatRequestRange struct {
	ChatID            string `json:"chat-id"`
	LowestRequestFrom int    `json:"lowest-request-from"`
	HighestRequestTo  int    `json:"highest-request-to"`
}
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS mailserver_chat_request_ranges (
    chat_id VARCHAR PRIMARY KEY,
    lowest_request_from INTEGER,
    highest_request_to INTEGER
) WITHOUT ROWID;
```

We don't need to change any of this.

### "permissions_addDappPermissions"

Stores provided permissions for dapp. On update replaces the previous version of the object.

```json
{
  "dapp": "first",
  "permissions": [
    "r",
    "x"
  ]
}
```

In `status-go/services/permissions/database.go`  the following datastructure is used:
```golang
type DappPermissions struct {
	Name        string   `json:"dapp"`
	Permissions []string `json:"permissions,omitempty"`
}
```

The following SQL statements are used:
```sql
"INSERT OR REPLACE INTO dapps(name) VALUES(?)"
"INSERT INTO permissions(dapp_name, permission) VALUES(?, ?)"
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS dapps (
name TEXT PRIMARY KEY
) WITHOUT ROWID;

CREATE TABLE IF NOT EXISTS permissions (
dapp_name TEXT NOT NULL,
permission TEXT NOT NULL,
FOREIGN KEY(dapp_name) REFERENCES dapps(name) ON DELETE CASCADE
);
```

`permissions` is passed as a vector of `string` and stored in a separate table using the `dapp` as a foreign key.
We don't need to change any of this

### "browsers_addBrowser"

Stores browser in the database. All fields are specified below:

```json
{
  "browser-id": "1",
  "name": "first",
  "timestamp": 10,
  "dapp?": true,
  "history-index": 1,
  "history": [
    "one",
    "two"
  ]
}
```

In `status-go/services/browsers/database.go`  the following datastructure is used:
```golang
type Browser struct {
	ID           string   `json:"browser-id"`
	Name         string   `json:"name"`
	Timestamp    uint64   `json:"timestamp"`
	Dapp         bool     `json:"dapp?"`
	HistoryIndex int      `json:"history-index"`
	History      []string `json:"history,omitempty"`
}
```

The following SQL statements are used:
```sql
"INSERT OR REPLACE INTO browsers(id, name, timestamp, dapp, historyIndex) VALUES(?, ?, ?, ?, ?)"
"INSERT INTO browsers_history(browser_id, history) VALUES(?, ?)"
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS browsers (
id TEXT PRIMARY KEY,
name TEXT NOT NULL,
timestamp USGIGNED BIGINT,
dapp BOOLEAN DEFAULT false,
historyIndex UNSIGNED INT
) WITHOUT ROWID;

CREATE TABLE IF NOT EXISTS browsers_history (
browser_id TEXT NOT NULL,
history TEXT,
FOREIGN KEY(browser_id) REFERENCES browsers(id) ON DELETE CASCADE
);
```

History is passed as a vector of string, but is stored as a blob of text. This is not critical data, and this is fine for this use case. We don't need to change any of this.

### "accounts_saveAccounts"

This endpoint seems to be missing documentation on `status-go` side. It is used to store one or more account in the database. Currently we only use it in `save-generated-account` which saves one account by passing a vector containing one map representing an `Account`.

In `status-go/multiaccounts/database.go` the following datastructure is used:
```golang
// Account stores public information about account.
type Account struct {
	Name           string         `json:"name"`
	Address        common.Address `json:"address"`
	Timestamp      int64          `json:"timestamp"`
	PhotoPath      string         `json:"photo-path"`
	KeycardPairing string         `json:"keycard-pairing"`
	KeycardKeyUID  string         `json:"keycard-key-uid"`
}
```

But this is not the datastructure we are looking for, the correct one is in `status-go/multiaccounts/accounts/database.go`:
```golang
type Account struct {
	Address   common.Address `json:"address"`
	Wallet    bool           `json:"wallet"`
	Chat      bool           `json:"chat"`
	Type      string         `json:"type"`
	Storage   string         `json:"storage"`
	Path      string         `json:"path"`
	PublicKey hexutil.Bytes  `json:"publicKey"`
	Name      string         `json:"name"`
	Color     string         `json:"color"`
}
```

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS accounts (
address VARCHAR PRIMARY KEY,
wallet BOOLEAN,
chat BOOLEAN,
type TEXT,
storage TEXT,
pubkey BLOB,
path TEXT,
name TEXT,
color TEXT
) WITHOUT ROWID;

CREATE UNIQUE INDEX unique_wallet_address ON accounts (wallet) WHERE (wallet);
CREATE UNIQUE INDEX unique_chat_address ON accounts (chat) WHERE (chat);
```

TODO: why is the pubkey a BLOB and not a string?

There doesn't seem to be any blob of json/transit stored here so we don't need to change any of this.

### "settings_saveConfig"

This is our main concern here as none of the other calls are using json/transit blobs in our json-rpc interface.

In `status-go/appdatabase/migrations/sql/0001_app.up.sql` the following schema is used:
```sql
CREATE TABLE IF NOT EXISTS settings (
type VARCHAR PRIMARY KEY,
value BLOB
) WITHOUT ROWID;
```

This is used as a key/value store for the following keys:

#### "networks"

The value is a transit serialization of :networks/networks which by default looks like this:
```clojure
{"testnet_rpc"
 {:id "testnet_rpc",
  :name "Ropsten with upstream RPC",
  :config
  {:NetworkId 3,
   :DataDir "/ethereum/testnet_rpc",
   :UpstreamConfig
   {:Enabled true,
    :URL
    "https://ropsten.infura.io/v3/f315575765b14720b32382a61a89341a"}}},
 "rinkeby_rpc"
 {:id "rinkeby_rpc",
  :name "Rinkeby with upstream RPC",
  :config
  {:NetworkId 4,
   :DataDir "/ethereum/rinkeby_rpc",
   :UpstreamConfig
   {:Enabled true,
    :URL
    "https://rinkeby.infura.io/v3/f315575765b14720b32382a61a89341a"}}},
 "goerli_rpc"
 {:id "goerli_rpc",
  :name "Goerli with upstream RPC",
  :config
  {:NetworkId 5,
   :DataDir "/ethereum/goerli_rpc",
   :UpstreamConfig
   {:Enabled true, :URL "https://goerli.blockscout.com/"}}},
 "mainnet_rpc"
 {:id "mainnet_rpc",
  :name "Mainnet with upstream RPC",
  :config
  {:NetworkId 1,
   :DataDir "/ethereum/mainnet_rpc",
   :UpstreamConfig
   {:Enabled true,
    :URL
    "https://mainnet.infura.io/v3/f315575765b14720b32382a61a89341a"}}},
 "xdai_rpc"
 {:id "xdai_rpc",
  :name "xDai Chain",
  :config
  {:NetworkId 100,
   :DataDir "/ethereum/xdai_rpc",
   :UpstreamConfig {:Enabled true, :URL "https://dai.poa.network"}}},
 "poa_rpc"
 {:id "poa_rpc",
  :name "POA Network",
  :config
  {:NetworkId 99,
   :DataDir "/ethereum/poa_rpc",
   :UpstreamConfig {:Enabled true, :URL "https://core.poa.network"}}}}
```

We could replace it with a `networks` table.

```sql
CREATE TABLE IF NOT EXISTS mailserver_topics (
    id VARCHAR PRIMARY KEY,
    name TEXT,
    config BLOB,
    current BOOLEAN DEFAULT FALSE,
) WITHOUT ROWID;
```

If not critical for v1, we could keep it like users would lose their custom networks when we change it

The schema of the config is not expected to change. But we could also flatten it and store it in the table

Will require:
- a `networks_getNetworks` rpc method to get the same datastructure that we currently serialize in transit and 
- a `networks_saveNetworks` rpc method to save/edit networks and their configs that will take a vector of networks as param. 

Later it will make more sense to also have a `networks_getCurrentNetwork` call, and only use that outside of settings, because there is no need for all networks in the app.

#### "current-network"

The value is a `string`. We could replace it by a `boolean` `current` in the `networks` table. 

Will require a `networks_setCurrentNetwork` endpoint which will take a `networkId` as param and will set the current network.

#### "multiaccount"

This is the most critical and the most complex part. It is a transit serialization of the `multiaccount` value from the app db. Here is what it contains for a new account:

```clojure
{:key-uid
 "0x4e8129f3edfc004875be17bf468a784098a9f69b53c095be1f52deff286935ab",
 :address "0xdC540f3745Ff2964AFC1171a5A0DD726d1F6B472",
 :mnemonic
 "danger ritual muscle point announce vocal foster during tree keep blade pledge",
 :signing-phrase "yurt joey vibe",
 :eip1581-address "0xB1DDDE9235a541d1344550d969715CF43982de9f",
 :hide-home-tooltip? true,
 :name "Jittery Cornflowerblue Kingbird",
 :latest-derived-path 0,
 :settings
 {:web3-opt-in? true,
  :preview-privacy? false,
  :wallet {:visible-tokens {:mainnet #{}}}},
 :wallet-root-address "0x3B591fd819F86D0A6a2EF2Bcb94f77807a7De1a6",
 :photo-path
 "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAIAAACRXR/mAAAAjklEQVR4nOzXwQmFMBAAUZXUYh32ZB32ZB02sxYQQSZGsod55/91WFgSS0RM+SyjA56ZRZhFmEWYRRT6h+M6G16zrxv6fdJpmUWYRbxsYr13dKfanpN0WmYRZhGzXz6AWYRZRIfbaX26fT9Jk07LLMIsosPt9I/dTDotswizCG+nhFmEWYRZhFnEHQAA///z1CFkYamgfQAAAABJRU5ErkJggg==",
 :dapps-address "0xD1300f99fDF7346986CbC766903245087394ecd0",
 :chaos-mode? false,
 :accounts
 [{:publicKey
   "0x0481f31992a3a980bde40984a790f4a6ad932b437b346f0215acf24bb0b1c1897ce4c11f4abea8501503191d5ff09c74c19990ac840df009057daa4160d0a9bd29",
   :address "0xD1300f99fDF7346986CbC766903245087394ecd0",
   :color "#4360df",
   :wallet true,
   :path "m/44'/60'/0'/0/0",
   :name "Status account"}],
 :public-key
 "0x04211fe0f69772ecf7eb0b5bfc7678672508a9fb01f2d699096f0d59ef7fe1a0cb1e648a80190db1c0f5f088872444d846f2956d0bd84069f3f9f69335af852ac0",
 :installation-id "d3efcff6-cffa-560e-a547-21d3858cbc51"}
 ```

When adding stickers and custom tokens we get the following:

```clojure
{:key-uid
 "0x4e8129f3edfc004875be17bf468a784098a9f69b53c095be1f52deff286935ab",
 :address "0xdC540f3745Ff2964AFC1171a5A0DD726d1F6B472",
 :mnemonic
 "danger ritual muscle point announce vocal foster during tree keep blade pledge",
 :signing-phrase "yurt joey vibe",
 :eip1581-address "0xB1DDDE9235a541d1344550d969715CF43982de9f",
 :hide-home-tooltip? true,
 :name "Jittery Cornflowerblue Kingbird",
 :latest-derived-path 0,
 :settings
 {:web3-opt-in? true,
  :preview-privacy? false,
  :wallet
  {:visible-tokens {:mainnet #{:ZIL}},
   :custom-tokens
   {:mainnet
    {"0x05f4a42e251f2d52b8ed15e9fedaacfcef1fad27"
     {:address "0x05f4a42e251f2d52b8ed15e9fedaacfcef1fad27",
      :name "Zilliqa",
      :symbol :ZIL,
      :custom? true,
      :decimals 12,
      :color "#fa6565"}}}}},
 :wallet-root-address "0x3B591fd819F86D0A6a2EF2Bcb94f77807a7De1a6",
 :photo-path
 "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAIAAACRXR/mAAAAjklEQVR4nOzXwQmFMBAAUZXUYh32ZB32ZB02sxYQQSZGsod55/91WFgSS0RM+SyjA56ZRZhFmEWYRRT6h+M6G16zrxv6fdJpmUWYRbxsYr13dKfanpN0WmYRZhGzXz6AWYRZRIfbaX26fT9Jk07LLMIsosPt9I/dTDotswizCG+nhFmEWYRZhFnEHQAA///z1CFkYamgfQAAAABJRU5ErkJggg==",
 :dapps-address "0xD1300f99fDF7346986CbC766903245087394ecd0",
 :chaos-mode? false,
 :wallet-set-up-passed? true,
 :stickers/packs-installed
 {1
  {:name "Status Cat",
   :author "cryptoworld1373",
   :thumbnail
   "e30101701220e9876531554a7cb4f20d7ebbf9daef2253e6734ad9c96ba288586a9b88bef491",
   :preview
   "e3010170122050efc0a3e661339f31e1e44b3d15a1bf4e501c965a0523f57b701667fa90ccca",
   :stickers
   [{:hash
     "e30101701220eab9a8ef4eac6c3e5836a3768d8e04935c10c67d9a700436a0e53199e9b64d29"}
    {:hash
     "e30101701220c8f28aebe4dbbcee896d1cdff89ceeaceaf9f837df55c79125388f954ee5f1fe"}
    {:hash
     "e301017012204861f93e29dd8e7cf6699135c7b13af1bce8ceeaa1d9959ab8592aa20f05d15f"}
    {:hash
     "e301017012203ffa57a51cceaf2ce040852de3b300d395d5ba4d70e08ba993f93a25a387e3a9"}
    {:hash
     "e301017012204f2674db0bc7f7cfc0382d1d7f79b4ff73c41f5c487ef4c3bb3f3a4cf3f87d70"}
    {:hash
     "e30101701220e8d4d8b9fb5f805add2f63c1cb5c891e60f9929fc404e3bb725aa81628b97b5f"}
    {:hash
     "e301017012206fdad56fe7a2facb02dabe8294f3ac051443fcc52d67c2fbd8615eb72f9d74bd"}
    {:hash
     "e30101701220a691193cf0559905c10a3c5affb9855d730eae05509d503d71327e6c820aaf98"}
    {:hash
     "e30101701220d8004af925f8e85b4e24813eaa5ef943fa6a0c76035491b64fbd2e632a5cc2fd"}
    {:hash
     "e3010170122049f7bc650615568f14ee1cfa9ceaf89bfbc4745035479a7d8edee9b4465e64de"}
    {:hash
     "e301017012201915dc0faad8e6783aca084a854c03553450efdabf977d57b4f22f73d5c53b50"}
    {:hash
     "e301017012200b9fb71a129048c2a569433efc8e4d9155c54d598538be7f65ea26f665be1e84"}
    {:hash
     "e30101701220d37944e3fb05213d45416fa634cf9e10ec1f43d3bf72c4eb3062ae6cc4ed9b08"}
    {:hash
     "e3010170122059390dca66ba8713a9c323925bf768612f7dd16298c13a07a6b47cb5af4236e6"}
    {:hash
     "e30101701220daaf88ace8a3356559be5d6912d5d442916e3cc92664954526c9815d693dc32b"}
    {:hash
     "e301017012203ae30594fdf56d7bfd686cef1a45c201024e9c10a792722ef07ba968c83c064d"}
    {:hash
     "e3010170122016e5eba0bbd32fc1ff17d80d1247fc67432705cd85731458b52febb84fdd6408"}
    {:hash
     "e3010170122014fe2c2186cbf9d15ff61e04054fd6b0a5dbd7f365a1807f6f3d3d3e93e50875"}
    {:hash
     "e30101701220f23a7dad3ea7ad3f3553a98fb305148d285e4ebf66b427d85a2340f66d51da94"}
    {:hash
     "e3010170122047a637c6af02904a8ae702ec74b3df5fd8914df6fb11c99446a36d890beeb7ee"}
    {:hash
     "e30101701220776f1ff89f6196ae68414545f6c6a5314c35eee7406cb8591d607a2b0533cc86"}],
   :id 1,
   :price 0}},
 :accounts
 [{:publicKey
   "0x0481f31992a3a980bde40984a790f4a6ad932b437b346f0215acf24bb0b1c1897ce4c11f4abea8501503191d5ff09c74c19990ac840df009057daa4160d0a9bd29",
   :address "0xD1300f99fDF7346986CbC766903245087394ecd0",
   :color "#4360df",
   :wallet true,
   :path "m/44'/60'/0'/0/0",
   :name "Status account"}],
 :public-key
 "0x04211fe0f69772ecf7eb0b5bfc7678672508a9fb01f2d699096f0d59ef7fe1a0cb1e648a80190db1c0f5f088872444d846f2956d0bd84069f3f9f69335af852ac0",
 :installation-id "d3efcff6-cffa-560e-a547-21d3858cbc51"}
 ```
 
TODO:
- accounts should not be stored there, as we have seen above they are already stored in a separate db
- stickers need a db and endpoints
- tokens need a db and endpoints
- bootnodes need a db and endpoints
- verify all usages of `status-im.multiaccounts.update.core/multiaccount-update` and `status-im.multiaccounts.update.core/update-settings` to see if there isn't anything missing
- flatten `settings` into `multiaccount`

### update-settings

- :datasync? boolean
- :v1-messages? boolean
- :disable-discovery-topic? boolean
- :web3-opt-in? boolean
- :preview-privacy? boolean
- :tribute-to-talk map
- :bootnodes map where keys are networks and values boolean
- :log-level string
- :desktop/desktop -> :logging-enabled boolean
- :wallet -> :currency string current currency
- :fleet string current fleet 
- :mailserver map where keys are fleets and values mailserver-ids
- :wallet -> :visible-tokens set of token symbols
- :wallet -> :custom-tokens replaced by custom token tables

### multiaccount-update

- :keycard-pairing ?
- :keycard-paired-on timestamp
- :keycard-instance-uid ?
- :usernames vector of names
- :preferred-names string (name)
- :show-name boolean
- :stickers/packs-installed blob of serialized sticker packs
- :stickers/recent-stickers ?
- :last-updated timestamp
- :accounts should bd replaced by the accounts db
- :latest-derived-path int
- :wallet-set-up-passed? boolean
- :hide-home-tooltip? boolean
- :dev-mode? boolean
- :notification-enabled? boolean
- :chaos-mode? boolean
- :desktop-notifications? boolean
- :dapps-address address of the account used for dapps
- :photo-path blob base64 image
- :syncing-on-mobile-network? boolean
- :remember-syncing-choice? boolean
- :bootnodes blob of serialized custom bootnodes
- :key-uid key-uid
- :address address
- :mnemonic string
- :eip1581-address?
- :name string random name
- :wallet-root-address address
- :installation-id string
- :public-key string


### "settings_saveNodeConfig"

This is just a special call of "settings_saveConfig" with `node-config` as key. The app will start the node with the config when the user logs in by looking up the `value` of the `type` `node-config` in the `settings` table

# Proposal

## Multiaccount settings


## Custom tokens

We create a table for custom tokens

```sql
CREATE TABLE IF NOT EXISTS tokens (
  address VARCHAR NOT NULL,
  network_id UNSIGNED BIGINT NOT NULL,
  name TEXT NOT NULL,
  symbol VARCHAR NOT NULL,
  decimals UNSIGNED INT,
  color VARCHAR,
  PRIMARY KEY (address, network_id)
) WITHOUT ROWID;
```

With 3 rpc methods to manage it:

- `getCustomTokens` to get a list of all custom tokens
- `addCustomTokens` to add or edit a custom token
- `removeCustomTokens` to remove a custom token

The token visibility will be passed as a list of string (token symbols) and stored in the single row multiaccount table for now. We will later investigate moving all tokens to a table or having a token visibility table but this is not as important as in the worst case scenario, users will have to toggle off the visibility of tokens they wanted to hide, as all tokens with a non-zero amount will be visible if this setting is lost.

## Custom bootnodes and stickers

We will store them in a field of the single row multiaccount table as JSON blobs.
We consider that in the worst case scenario where we can't migrate them, it is not a big loss as users can easily reinstall their stickers and custom bootnodes is an advanced feature that few will use. We will however move them to separate table to fix this promptly after v1.
