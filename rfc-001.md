**Stakeholder:** @rachelhamlin, @carlbennetts 
**Engineer:** @yenda

## Introduction

We want to make it easy & painless to send SNT via Status so our marketing team can welcome new users with tokens during launch.

## Current Status

Chat commands are currently disabled, which means that we don't have a flow for users to send or receive funds in a structured way. Additionally, users have no information about each other's wallets in v1 (as we have decoupled them from the Whisper key.) Lastly, contacts never exchange wallet information with each other.

## The Problem

To facilitate the smooth distribution of SNT by our marketing team, we want to re-enable chat commands. In a multi-account world, this is not a straightforward problem to solve. We have taken privacy and security considerations to heart in the following options.

Part of the beauty of multi-account and the decoupled keys is that the user has a higher degree of privacy. We want to uphold that as much as possible while still facilitating transactions between casual acquaintances or even strangers.

## Why Don't We Just ...

### ... Share the Address as Text in Chat?

Sharing the wallet address as text in chat is very inconvenient, for multiple reasons, chiefly being that copying and pasting text in mobile isn't exactly smooth. The in-chat request solution is equivalent, but just much more convenient, and follows a curated flow.

### ... Share the Address in Every Message? (like we do with ENS name)

Sending the ENS name with every message was already a discussion that we've had and wasn't something we were 100% sure about. As a result, wallet address seems even more at odds, as it isn't directly related to chat unlike the ENS name which is meant to be displayed, and was ultimately added to each message for the sake of simplicity (checking if a user has an ENS name would have required a reverse lookup and to be done on every message, when the current solution only requires to check the validity of the claim for names you don't already know.) It is also spammy, as it adds unnecessary bandwidth and storage for little return.

Not only that, we can't guarantee that the wallet information is up to date, and if we want to allow the user to choose which address to share, it would have to be stored as a preference, which then would have to potentially be synced across multiple devices.

Ultimately, we don't allow custom usernames. Why would we allow custom wallets to be defined in each message? If someone wants to define a wallet in each message, they can use an ENS name, which already binds to a wallet.

### ... Use Hot Wallet Using Chat Private Key?

Creating this wallet when creating/recovering an account is a low effort. However, this is already how the wallet was generated in beta. Now, wallets are generated from a separate derivation path than the chat key. The driver for this is so that users can have the chat key on the phone and keep their wallets on a Keycard. 

Also, only the chat key is loaded in memory (to decrypt messages), which means that we would go back to square one and share again the same private key for the chat and wallet account (so they'd essentially be the same.) The biggest concerns with that are security and privacy. 
It will require us to think hard about the UX to help the users understand and maintain their wallet hygiene (too many funds and it becomes a target, no privacy as everyone can link this wallet to their chat account, risk of revealing other private wallets when making transactions from/to the hot wallet), so the effort isn't even that low, as there are so many issues to take into consideration if we open that door again.

One strong argument for this is that it would enable SNT reactions, however, this feature could be done with a contract so that isn't a requirement.

Note that the address of the wallet account that is used to register the ENS name is revealed publicly because it is directly associated with the ENS name in the contract (as warned in the ens registration process.)

### ... Profile Settings / Wallet Sharing?

When you add a user as a contact, you share your wallet address in the contact request. The wallet account that you share with your contacts comes from your profile settings.

The issue with this scenario is that the user will have to know that they need to add someone as a contact to share their wallet address and to be able to receive funds from another user. They will also need to know that they need to be added back by that person to be able to send funds.

As such, this solution doesn't simplify anything compared to the in-chat wallet sending/requesting flow, but **could complement it in the future.** 
In the interest of time, we stand to gain more by focusing on the in-chat flow first.

Additionally, the fact that someone added you as contact isn't necessarily information that is directly communicated to the user at the moment it happens, but rather something that can be inferred because of the information that the user shares with you (profile picture, contact updates.)

##  In-Chat Request Proposal using GUI commands

- The user selects the wallet they want to receive the funds into when sending a fund request
- More secure (because the wallet and chat accounts are different, and unlike the chat's private key, the wallet keys are not in memory) and private (because the wallet address cannot be inferred, the user has to share it) than a hot wallet.
- Happens in the context of a conversation.
- The user picks which wallet to share with each person.
- Not necessary for users who have an ENS name.
- Does not enable sending to people directly from the wallet (unless the user has an ENS name)

**Ease of Use:** High
It is clear to the user that, when he wants to send funds, he makes a request and chooses a wallet. The sender signs the transaction that opens on the request. When the user wants to receive funds, the simplicity will depend on the variant.

**Privacy:** Reasonable 
You reveal your wallet address when you make a request, and since you are sending the request in a message signed with your private key (ie. you can't deny you asked me to send to this address.) It doesn't show that it is yours, but it does prove that you asked me to send funds there.

**Effort / Complexity:** Medium

### Scenarios

#### Alice wants to send funds to Bob

- Alice triggers a "send funds" action, select the asset and amount and send the command to Bob.
- On the wire, this is a `command/request-address-for-transaction` message-type, without a wallet address
- At this point, Alice didn't sign a transaction yet because she doesn't know Bob's address
- Bob receives the send command from Alice, which displays as an invitation to share his address with Alice so that she can complete the transaction
- On the wire, this is a `command/request-transaction`, with the wallet address
- Bob then sees the command as "waiting for Alice to complete the transaction"
- Alice then sees the command as an action, tapping on it, she opens her wallet and signs the transaction.
- On the wire, this is a `command/send-transaction`, with the transaction hash
- Bob then sees the usual command for when one receives a transaction.

#### Bob requests funds from Alice

- Bob sends a request command by selecting the asset, amount, and the wallet address he wants to receive into.
- Alice receives the command that displays as an action. Tapping on it, it opens the signing flow and she signs the transaction.
- Bob then sees the usual command for when one receives a transaction.

### Implementation

Following up on the design team recommendations and [technical analysis of the current implementation of text commands](annex-001.md) , we propose implementing the GUI commands.
Textual commands are replaced by GUI commands. As a result, the send and request commands flow is essentially the same as the wallet send transaction flow and all the code in `status-im.chat.commands` namespaces are deleted.

#### Design

https://www.figma.com/file/XUehMnhyD1FGcWzvGz6SXqvh/Wallet?node-id=4520%3A37198

#### Spec of the messages

Currently, commands are all using the same `command` content type. The spec in `status-im.transport.db` loosely defines a command as a message that has the `content-type` `command` and a `content` that contains `command-path` and `params` which is just a map without further specification.

The specification is updated to introduce the `command/transaction` `content-type` which will be generated by status-go after processing the following message types which have parameters based on EIPs: 
- `send-transaction`  used after the transaction has been sent to notify the recipient, based on EIP proposal for [`transaction-hash-uri`](https://notes.status.im/Mc8cH-HdS8qCIVd7fqetaA#), itself based on [EIP-831](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-831.md).
- `request-transaction` used to request funds or reply to a `command/request-address-for-transaction` message, based on [EIP-681](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-681.md).
- `request-address-for-transaction` used to show an intent to send funds, expecting a request in response with the recipient address, based on [EIP-681](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-681.md) with unknown recipient address.

##### On the wire

On the wire, the command messages are going to use parameters that are defined in the protobuf schemas rather than the URI directly to achieve better parsing time and upgradability. For cases where having a URI would be desirable, like for other chat clients over a bridge, for instance, we can still construct a valid URI from these parameters and pass it as a regular message.

Note: this document will be updated after the protobuf schemas have been implemented

Commands will be implemented as a separate message type in v1, with the 3 following commands:
- `request-address-for-transaction`:
  - `target_address`: erc20 token transfer only, ethereum address
  - `chain_id`: 1 digit, the ID of the chain
  - `function_name`: erc20 token transfer only, always string "transfer"
  - `parameters`: erc20 token transfer only, vector of parameter types and values `["uint256" value "address" null]`
  - `value`: ETH transfer only, bigint
  
- `request-transaction`:
  - `target_address`: ethereum address, mandatory. For an ETH transfer it is the recipient address, for an erc20 token transfer it is the address of the token contract
  - `chain_id`: 1 digit, the ID of the chain
  - `function_name`: erc20 token transfer only, always string "transfer"
  - `parameters`: erc20 token transfer only, vector of parameter types and values `["uint256" value "address" recipient-address]`
  - `value`: ETH transfer only, bigint

- `send-transaction`, 
  - `chain_id` 1 digit, the ID of the chain so we can quickly check if the message refers to a transaction on the same chain the recipient is using
  - `transaction_hash` hash of the transaction

There will also be command updates, which will be the results of RPC calls from status-react whose effects are defined in the next section. The details of their implementation will be filled after the protobuf changes are made.

  Backward compatibility note:
  
  The current version will only support the `function_name` transfer that corresponds to an erc20 token transfer but in the future, we might support arbitrary contract call. For this reason, `status-go` needs to check `function_name` and ignore it or show a `not-implemented` system message.
  
##### status-go/status-react interface

If the `chain-id` of a `command` doesn't match the current `chain-id` of the user, the message is not passed to `status-react`.

On the UI side, all the commands described above will be represented by the same message of `content-type` `command/transaction` with the following parameters:
  - `chat-id`: the chat-id
  - `clock-value`: the clock value
  - `direction`: `:outgoing` if the final transaction is from the user or `:incoming` if it is to the user
  - `command-state`: there are 6 different states for the command message UI
    - `:request-address-for-transaction`: possible initial state, 
    - `:request-address-for-transaction-declined`: possible final state, reached when the user declines to share his address
    - `:request-transaction` possible initial state when using the request command GUI, or reached when the user shared his address in response to a `request-address-for-transaction` command
    - `request-transaction-declined`, possible final state, reached when a request for a transaction is declined 
    - `transaction-pending`: only for the transaction sender because when sending a transaction through the `send-transaction` command, `status-go` will hold the message until the transaction is confirmed and only send it then so that the `command/transaction` message only updates for the recipient once the transaction has been confirmed. On the receiving end, `status-go` will check the transaction and fill the message fields based on the transaction parameters before sending it to `status-react`.
    - `transaction-sent` possible initial state when using the send command GUI in a chat with a user that has an ens name pointing to an account, or when modifying the transaction requested which will show in a separate message. Final state, the transaction was mined.
  - `transaction-hash`: "0x" 64*64HEXDIG the hash of the transaction
  - `to`: the address of the recipient of the transaction/token transfer
  - `value`: bigint, amount of the transaction
  - `contract`: only for erc20 token transfers, address of the token contract

- In the `request-address-for-transaction` command state, if the direction is `:incoming`, the user can choose between "Accept and share address" and "Decline" actions, which will move the command to the next state. Declining will move the command to the final `:request-address-for-transaction-declined` stage while picking an address will move it to the `request-transaction` stage.
- In the `request-transaction` command state, if the direction is `outgoing`, the user can choose between "Sign and send" and "Decline" actions. Declining will move the command to the final `request-transaction-declined` stage while signing will move locally to the `transaction-pending` state. Once the transaction is mined it will move to the final stage `transaction-sent`

For clarity we will start with a separate rpc endpoint for each command and possible update:

- `commands_requestAddressForTransaction`:
  - `publicKey`: the public key of the contact
  - `value`: bigint, amount of the transaction
  - `contract`: only for erc20 token transfers, address of the token contract
  
- `commands_acceptRequestAddressForTransaction`:
  - `messageId`: id of the declined `command/transaction` message
  - `address`: the address of the account recipient of the transaction
  
- `commands_declineRequestAddressForTransaction`:
  - `messageId`: id of the declined `command/transaction` message in the `:request-address-for-transaction` state
  
- `commands_requestTransaction`:
  - `publicKey`: the public key of the contact
  - `to`: the address of the recipient of the transaction/token transfer
  - `value`: bigint, amount of the transaction
  - `contract`: only for erc20 token transfers, address of the token contract
  
- `commands_acceptRequestTransaction`:
  - `messageId`: id of the accepted `command/transaction` message in the `:request-transaction` state
  - `transactionHash`: the id of the transaction
  
- `commands_declineRequestTransaction`:
  - `messageId`: id of the declined `command/transaction` message
  
- `commands_sendTransaction`:
  - `transactionHash`: the id of the transaction

On the sending end, if you change the values of a transaction when signing a request, `commands_sendTransaction` is sent instead of `commands_acceptRequestTransaction` because it is no longer considered as an accepted request but as a new one.
On the receiving end, status-go will ignore the result of `commands_acceptRequestTransaction` if the transaction isn't successful or doesn't match the params of the request with the `messageId` it is referring to.
