**Stakeholder:** @rachelhamlin, @carlbennetts 
**Engineer:** @yenda

## Introduction

We want to make it easy & painless to send SNT via Status so our marketing team can welcome new users with tokens during launch.

## Current Status

Chat commands are currently disabled, which means that we don't have a flow for users to send or receive funds in a structured way. Additionally, users have no information about each other's wallets in v1 (as we have decoupled them from the Whisper key.) Lastly, contacts never exchange wallet information with each other.

## The Problem

To facilitate the smooth distribution of SNT by our marketing team, we want to re-enable chat commands. In a multi-account world, this is not a straightforward problem to solve. We have taken privacy and security considerations to heart in the following options.

Part of the beauty of multi-account and the decoupled keys is that the user has a higher degree of privacy. We want to uphold that as much as possible while still facilitating transactions between casual acquaintances or even strangers.

## Why Don't We Just ...

### ... Share the Address as Text in Chat?

Sharing the wallet address as text in chat is very inconvenient, for multiple reasons, chiefly being that copying and pasting text in mobile isn't exactly smooth. The in-chat request solution is equivalent, but just much more convenient, and follows a curated flow.

### ... Share the Address in Every Message? (like we do with ENS name)

Sending the ENS name with every message was already a discussion that we've had and wasn't something we were 100% sure about. As a result, wallet address seems even more at odds, as it isn't directly related to chat unlike the ENS name which is meant to be displayed, and was ultimately added to each message for the sake of simplicity (checking if a user has an ENS name would have required a reverse lookup and to be done on every message, when the current solution only requires to check the validity of the claim for names you don't already know.) It is also spammy, as it adds unnecessary bandwidth and storage for little return.

Not only that, we can't guarantee that the wallet information is up to date, and if we want to allow the user to choose which address to share, it would have to be stored as a preference, which then would have to potentially be synced across multiple devices.

Ultimately, we don't allow custom usernames. Why would we allow custom wallets to be defined in each message? If someone wants to define a wallet in each message, they can use an ENS name, which already binds to a wallet.

### ... Use Hot Wallet Using Chat Private Key?

Creating this wallet when creating/recovering an account is a low effort. However, this is already how the wallet was generated in beta. Now, wallets are generated from a separate derivation path than the chat key. The driver for this is so that users can have the chat key on the phone and keep their wallets on a Keycard. 

Also, only the chat key is loaded in memory (to decrypt messages), which means that we would go back to square one and share again the same private key for the chat and wallet account (so they'd essentially be the same.) The biggest concerns with that are security and privacy. 
It will require us to think hard about the UX to help the users understand and maintain their wallet hygiene (too many funds and it becomes a target, no privacy as everyone can link this wallet to their chat account, risk of revealing other private wallets when making transactions from/to the hot wallet), so the effort isn't even that low, as there are so many issues to take into consideration if we open that door again.

One strong argument for this is that it would enable SNT reactions, however, this feature could be done with a contract so that isn't a requirement.

Note that the address of the wallet account that is used to register the ENS name is revealed publicly because it is directly associated with the ENS name in the contract (as warned in the ens registration process.)

### ... Profile Settings / Wallet Sharing?

When you add a user as a contact, you share your wallet address in the contact request. The wallet account that you share with your contacts comes from your profile settings.

The issue with this scenario is that the user will have to know that they need to add someone as a contact to share their wallet address and to be able to receive funds from another user. They will also need to know that they need to be added back by that person to be able to send funds.

As such, this solution doesn't simplify anything compared to the in-chat wallet sending/requesting flow, but **could complement it in the future.** 
In the interest of time, we stand to gain more by focusing on the in-chat flow first.

Additionally, the fact that someone added you as contact isn't necessarily information that is directly communicated to the user at the moment it happens, but rather something that can be inferred because of the information that the user shares with you (profile picture, contact updates.)

##  In-Chat Request Proposal using GUI commands

- The user selects the wallet they want to receive the funds into when sending a fund request
- More secure (because the wallet and chat accounts are different, and unlike the chat's private key, the wallet keys are not in memory) and private (because the wallet address cannot be inferred, the user has to share it) than a hot wallet.
- Happens in the context of a conversation.
- The user picks which wallet to share with each person.
- Not necessary for users who have an ENS name.
- Does not enable sending to people directly from the wallet (unless the user has an ENS name)

**Ease of Use:** High
It is clear to the user that, when he wants to send funds, he makes a request and chooses a wallet. The sender signs the transaction that opens on the request. When the user wants to receive funds, the simplicity will depend on the variant.

**Privacy:** Reasonable 
You reveal your wallet address when you make a request, and since you are sending the request in a message signed with your private key (ie. you can't deny you asked me to send to this address.) It doesn't show that it is yours, but it does prove that you asked me to send funds there.

**Effort / Complexity:** Medium

### Scenarios

#### Alice wants to send funds to Bob

- Alice triggers a "send funds" action, select the asset and amount and send the command to Bob.
- On the wire, this is a `command/send-request` message-type, without a wallet address
- At this point, Alice didn't sign a transaction yet because she doesn't know Bob's address
- Bob receives the send command from Alice, which displays as an invitation to share his address with Alice so that she can complete the transaction
- On the wire, this is a `command/request`, with the wallet address
- Bob then sees the command as "waiting for Alice to complete the transaction"
- Alice then sees the command as an action, tapping on it, she opens her wallet and signs the transaction.
- On the wire, this is a `command/send`, with the transaction hash
- Bob then sees the usual command for when one receives a transaction.

#### Bob requests funds from Alice

- Bob sends a request command by selecting the asset, amount, and the wallet address he wants to receive into.
- Alice receives the command that displays as an action. Tapping on it, it opens the signing flow and she signs the transaction.
- Bob then sees the usual command for when one receives a transaction.

### Implementation

Following up on the design team recommendations and [technical analysis of the current implementation of text commands](annex-001.md) , we propose implementing the GUI commands.
Textual commands are replaced by GUI commands. As a result, the send and request commands flow is essentially the same as the wallet send transaction flow and all the code in `status-im.chat.commands` namespaces are deleted.

#### Design

https://www.figma.com/file/XUehMnhyD1FGcWzvGz6SXqvh/Wallet?node-id=4520%3A37198

#### Spec of the messages

Currently, commands are all using the same `command` content type. The spec in `status-im.transport.db` loosely defines a command as a message that has the `content-type` `command` and a `content` that contains `command-path` and `params` which is just a map without further specification.

The specification is updated to introduce the 3 following `content-types` with parameters based on EIPs: 
- `command/send`  used after the transaction has been sent to notify the recipient, based on EIP proposal for [`transaction-hash-uri`](https://notes.status.im/Mc8cH-HdS8qCIVd7fqetaA#), itself based on [EIP-831](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-831.md).
- `command/request` used to request funds or reply to a `command/send-request` message, based on [EIP-681](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-681.md).
- `command/send-request` used to show an intent to send funds, expecting a request in response with the recipient address, based on [EIP-681](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-681.md) with unknown recipient address.

##### On the wire

On the wire, the command messages are going to use parameters that are defined in the protobuf schemas rather than the URI directly in order to achieve better parsing time and upgradability. For cases where having a URI would be desirable, like for other chat clients over a bridge for instance, we can still construct a valid URI from these parametersand pass it as a regular message.

Note: this document will be updated after the protobuf schemas have been implemented

Here are the supported parameters for v1:
- `command/send`, 
  - `chain_id` 1 digit, the ID of the chain so we can quickly check if the message refers to a transaction on the same chain the recipient is using
  - `transaction_hash` hash of the transaction

- `command/send-request`:
  - `target_address`: erc20 token transfer only, ethereum address
  - `chain_id`: 1 digit, the ID of the chain
  - `function_name`: erc20 token transfer only, always string "transfer"
  - `parameters`: erc20 token transfer only, vector of parameter types and values `["uint256" value "address" null]`
  - `value`: ETH transfer only, bigint
  
- `command/request`:
  - `target_address`: ethereum address, mandatory. For an ETH transfer it is the recipient address, for an erc20 token transfer it is the address of the token contract
  - `chain_id`: 1 digit, the ID of the chain
  - `function_name`: erc20 token transfer only, always string "transfer"
  - `parameters`: erc20 token transfer only, vector of parameter types and values `["uint256" value "address" recipient-address]`
  - `value`: ETH transfer only, bigint
  
  Backward compatibility note:
  
  The current version will only support the `function_name` transfer that corresponds to an erc20 token transfer but in the future we might support arbitrary contract call. For this reason `status-go` needs to check `function_name` and ignore it or show a `not-implemented` system message.
  
##### status-go/status-react interface

- `command/send`:
  - `chain-id`: 1 digit, the ID of the chain
  - `status`: `pending`, `confirmed`, `failed`
  - `transaction-hash`: "0x" 64*64HEXDIG the hash of the transaction
  - `to`: the address of the recipient of the transaction/token transfer
  - `value`: bigint, amount of the transaction
  - `contract`: only for erc20 token transfers, address of the token contract

Additionally, `status-go` will update `status-react` on the `status` of transaction through a `message.update` signal that will contain `chat-id`, `message-id` and `status`.

- `command/send-request`:
  - `chain-id`: 1 digit, the ID of the chain
  - `contract`: only for erc20 token transfers, address of the token contract
  - `value`: bigint, amount of the transaction
  
- `command/request`:
  - `chain-id`: 1 digit, the ID of the chain
  - `contract`: only for erc20 token transfers, address of the token contract
  - `value`: bigint, amount of the transaction
  - `address`: ethereum address of the recipient account
